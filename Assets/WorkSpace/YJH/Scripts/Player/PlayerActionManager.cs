using Photon.Pun;

using System;

using System.Collections;

using TMPro;

using UnityEngine;

using UnityEngine.UI;

using ZL.Unity.Unimo;

public partial class PlayerManager : IEnergizer
{
    [SerializeField]

    private GameObject gatheringAuraPlane;

    [SerializeField]

    private GameObject gatheringEffect;

    [Header("채집 소리")]

    [SerializeField]

    private AudioClip gatheringAudioClip;

    [SerializeField]

    private AudioSource gatheringAudioSource;

    [Header("탐지할 오브젝트의 레이어")]

    [SerializeField]

    private LayerMask itemLayerMask;

    [Header("탐지할 적의 레이어")]

    [SerializeField]

    private LayerMask enemyLayerMask;

    private static GameObject attackPrefab;

    public GameObject tempAttackPrefab;

    private static IAttackType playerAttackType;

    private static ISpellType playerSpellType = new Dash();

    private int playerOwnEnergy = 0;

    public int Energy
    {
        get => playerOwnEnergy;

        set => playerOwnEnergy = value;
    }

    private GameObject targetObject;

    private GameObject targetEnemyObject;

    private bool isGatheringCoroutineWork = false;

    public delegate void OnTargetSet();

    public event OnTargetSet OnTargetObjectSet;

    private Vector3 firePos;

    private static PlayerManager selfManager;

    public static PlayerManager SelfManager
    {
        get => selfManager;
    }

    [SerializeField]

    Image progressBarCircle;

    [SerializeField]

    TMP_Text progressBarText;

    [SerializeField]

    private TMP_Text skillRejectText;

    private bool isSkillRejectActive = false;

    private bool isItemNear = false;

    [SerializeField]

    private SphereCollider detectCollider;

    public static event Action<float> OnEnergyChanged = null;

    private Coroutine gatheringCoroutine;

    // 멀티용으로 리펙토링한거 나중에 다 해체하기
    public void ActionStart()
    {
        if (attackPrefab == null)
        {
            SetAttackType(tempAttackPrefab);
        }

        else
        {
            SetAttackType(attackPrefab);
        }

        if (playerSpellType != null)
        {
            playerSpellType.InitSpell();
        }

        else
        {
            ISpellType temp = new Dash();

            SetSpellType(temp);

            playerSpellType.InitSpell();
        }
    }

    public void ActionUpdate()
    {
        if (playerSpellType != null)
        {
            playerSpellType.UpdateTime();

            switch (playerSpellType)
            {
                case IStackSpell:

                    if (progressBarCircle != null && progressBarText != null)
                    {
                        if ((playerSpellType as IStackSpell).NowStack == (playerSpellType as IStackSpell).MaxStack)
                        {
                            progressBarCircle.fillAmount = 1;
                        }

                        else
                        {
                            progressBarCircle.fillAmount = (playerSpellType as IStackSpell).Timer / (playerSpellType as IStackSpell).ChargeTime;
                        }

                        progressBarText.text = (playerSpellType as IStackSpell).NowStack.ToString();
                    }

                    break;

                case ICoolTimeSpell:

                    // 나중에 쿨타임 스킬 필요하면 리펙토링

                    //progressBarCircle.fillAmount = (playerSpellType as ICoolTimeSpell).Timer / (playerSpellType as IStackSpell).ChargeTime;

                    //progressBarText.text = (playerSpellType as ICoolTimeSpell).NowStack.ToString();

                    break;

                default:

                    break;
            }
        }

        FindItemUpdate();
    }

    public static void SetAttackType(GameObject attackType)
    {
        attackPrefab = attackType;

        playerAttackType = attackPrefab.GetComponent<IAttackType>();

        playerAttackType.Damage = playerStatus.playerDamage;
    }

    public static void SetSpellType(ISpellType spellType)
    {
        playerSpellType = spellType;

        playerSpellType.SetPlayer(selfManager);
    }

    public void GetItem(IGatheringObject temp)
    {
        temp.UseItem();
    }

    //멀티에서도 공격이 있나? -> 있음
    public void GetEnergy(int value)
    {
        playerOwnEnergy += value;

        if (playerOwnEnergy >= playerAttackType.EnergyCost)
        {
            FindEnemy();

            Vector3 tempDirection;

            if (targetEnemyObject != null)
            {
                tempDirection = targetEnemyObject.transform.position - transform.position;

                firePos = transform.position + tempDirection.normalized * 1.5f;
            }

            else
            {
                tempDirection = transform.forward;

                firePos = transform.position + tempDirection.normalized * 1.5f;
            }

            Vector3 direction = tempDirection.normalized;

            Vector3 right = Vector3.Cross(Vector3.up, direction).normalized;

            float spacing = 1.5f;

            int fireCount = playerOwnEnergy / playerAttackType.EnergyCost;

            for (int i = 0; i < fireCount; i++)
            {
                int offsetIndex = 0;

                // 짝수일 때
                if (fireCount % 2 == 0)
                {
                    int step = (i / 2) + 1;

                    // 좌 → 우
                    int sign = (i % 2 == 0) ? -1 : 1;

                    offsetIndex = step * sign;
                }

                else
                {
                    if (i == 0)
                    {
                        // 중앙
                        offsetIndex = 0;
                    }

                    else
                    {
                        int step = (i + 1) / 2;

                        int sign = (i % 2 == 1) ? -1 : 1;

                        offsetIndex = step * sign;
                    }
                }

                Vector3 spawnPos = firePos + right * offsetIndex * spacing;

                if (PhotonNetwork.IsConnected)
                {
                    photonView.RPC("PlayerAttack", RpcTarget.All, spawnPos);
                }

                else
                {
                    PlayerAttack(spawnPos);
                }
            }

            playerOwnEnergy %= playerAttackType.EnergyCost;
        }

        OnEnergyChanged?.Invoke(playerOwnEnergy);
    }

    // 한번에 2개 이상 먹을 시 가로로 늘려서 발사하는 것으로
    public void PlayerAttack()
    {
        playerOwnEnergy -= playerAttackType.EnergyCost;

        var bullet = Instantiate(attackPrefab, firePos, Quaternion.identity);

        if (targetEnemyObject != null)
        {
            bullet.GetComponent<IAttackType>().Shoot(targetEnemyObject.transform.position - firePos);
        }

        else
        {
            bullet.GetComponent<IAttackType>().Shoot(firePos - transform.position);
        }
    }

    [PunRPC]

    public void PlayerAttack(Vector3 firePosition)
    {
        playerOwnEnergy -= playerAttackType.EnergyCost;

        GameObject bullet;

        if (PhotonNetwork.IsConnected == false)
        {
            bullet = Instantiate(attackPrefab, firePosition, Quaternion.identity);
        }

        else
        {
            bullet = PhotonNetwork.Instantiate(attackPrefab.name, firePosition, Quaternion.identity);
        }

        if (targetEnemyObject != null)
        {
            bullet.GetComponent<IAttackType>().Shoot(targetEnemyObject.transform.position - firePos);
        }

        else
        {
            bullet.GetComponent<IAttackType>().Shoot(firePos - transform.position);
        }
    }

    public void GatheringItem()
    {
        if (isGatheringCoroutineWork == false)
        {
            isGatheringCoroutineWork = true;

            gatheringCoroutine = StartCoroutine(GatheringCoroutine());
        }

        else
        {
            return;
        }
    }

    public void FindEnemy()
    {
        Collider[] targetEnemies = Physics.OverlapSphere(transform.position, 100f, enemyLayerMask);

        float distance = float.MaxValue;

        if (targetEnemies.Length > 0)
        {
            foreach (Collider collider in targetEnemies)
            {
                // 감지된 콜라이더와의 거리
                float distanceBetween = Vector3.Distance(transform.position, collider.transform.position);

                // 1.거리 비교 조건
                if (distance > distanceBetween)
                {
                    distance = distanceBetween;

                    targetEnemyObject = collider.gameObject;
                }
            }
        }

        else
        {
            targetEnemyObject = null;
        }
    }

    [PunRPC]

    public void ActiveGatheringBeam()
    {
        gatheringEffect.SetActive(true);
    }

    [PunRPC]

    public void DeactiveGatheringBeam()
    {
        gatheringEffect.SetActive(false);
    }

    private void FindItemUpdate()
    {
        if (targetObject == null)
        {
            isGathering = false;
        }

        else
        {
            if (Vector3.Distance(transform.position, targetObject.transform.position) > playerStatus.itemDetectionRange + float.Epsilon)
            {
                isGathering = false;

                targetObject = null;
            }
        }

        if (isGathering == false && playerSpellType.ReturnState() == false)
        {
            Collider[] detectedColliders = Physics.OverlapSphere(transform.position, playerStatus.itemDetectionRange, itemLayerMask);

            if (detectedColliders.Length > 0)
            {
                float distance = float.MaxValue;

                foreach (Collider collider in detectedColliders)
                {
                    // 감지된 콜라이더와의 거리
                    float distanceBetween = Vector3.Distance(transform.position, collider.transform.position);

                    // 1.거리 비교 조건
                    if (distance > distanceBetween)
                    {
                        distance = distanceBetween;

                        targetObject = collider.gameObject;
                    }

                    else if (distance == distanceBetween)
                    {
                        if (targetObject != null)
                        {
                            var targetScript = targetObject.GetComponent<Gathering>();

                            var colliderScript = collider.GetComponent<Gathering>();

                            // 2. 체력 비교 조건
                            if (targetScript.CurrentHealth > colliderScript.CurrentHealth)
                            {
                                targetObject = collider.gameObject;
                            }

                            // 3. 등급 비교 조건
                            else if (targetScript.CurrentHealth == colliderScript.CurrentHealth)
                            {
                                if (targetScript.GatheringData.MaxHealth < colliderScript.GatheringData.MaxHealth)
                                {
                                    targetObject = collider.gameObject;
                                }
                            }
                        }
                    }
                }

                isGathering = true;

                if (targetObject != null)
                {
                    ActiveGatheringBeam();
                }

                GatheringItem();
            }

            else
            {
                isGathering = false;

                DeactiveGatheringBeam();

                targetObject = null;
            }
        }
    }

    // 아이템 채집중 사용할 코루틴
    private IEnumerator GatheringCoroutine()
    {
        Gathering targetScript = null;

        if (targetObject != null)
        {
            targetScript = targetObject.GetComponent<Gathering>();
        }

        while (true)
        {
            if (targetObject == null)
            {
                targetScript = null;

                isGatheringCoroutineWork = false;

                yield break;
            }

            yield return new WaitForSeconds(playerStatus.gatheringDelay);

            targetScript?.TakeDamage(playerStatus.gatheringSpeed);

            if (targetScript?.CurrentHealth <= 0f)
            {
                targetObject = null;

                isGathering = false;

                isGatheringCoroutineWork = false;

                yield break;
            }
        }
    }

    private Coroutine fadeCoroutine;

    public void ActiveSkillReject()
    {
        skillRejectText.text = "스킬을 사용할 수 없습니다.";

        // 효과음 출력
        if (isSkillRejectActive == false)
        {
            isSkillRejectActive = true;

            fadeCoroutine = StartCoroutine(FadeOutReject());
        }

        else
        {
            StopCoroutine(fadeCoroutine);

            fadeCoroutine = StartCoroutine(FadeOutReject());
        }
    }

    private IEnumerator FadeOutReject()
    {
        Color color = Color.white;

        skillRejectText.color = color;

        yield return new WaitForSeconds(1f);

        while (true)
        {
            color.a -= Time.deltaTime;

            skillRejectText.color = color;

            if (color.a <= 0f)
            {
                isSkillRejectActive = false;

                yield break;
            }

            yield return null;
        }
    }

    private void OnDrawGizmosSelected()
    {
        Gizmos.color = Color.red;

        Gizmos.DrawWireSphere(transform.position, playerStatus.itemDetectionRange);
    }

    public void OnUseSpell()
    {
        playerSpellType.UseSpell();

        DeactiveGatheringBeam();
    }
}